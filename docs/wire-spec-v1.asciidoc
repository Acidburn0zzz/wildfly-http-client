= Wildfly Service Invocation over HTTP Specification
:Author:    Stuart Douglas
:Email:     <sdouglas@redhat.com>
:Date:      2016
:Revision:  1.0
:toc:   left


== Overview

This document specifies the way in which EJB and other services may be invoked over HTTP. At present this includes:

* EJB
* JNDI
* Transactions

However more may be added in future versions.

=== Design notes

This protocol is intended to conform to HTTP semantics as closely as possible, however it is not intended to be a RESTful protocol. The semantics of EJB invocation to not necessarily map well to REST, and JAX-RS already provides a standard way to map EJB invocation to RESTful web services.

== Protocol

The protocol is based on HTTP, and is intended to be used over both HTTP/1.1 and HTTP/2. All services are mapped a location in the _Cluster Service Context Path_ which by default is +/wildfly-services+. This context path is configurable per connector, and can be disabled entirely. Each specific protocol will be mapped to a sub location inside the service context path. For example EJB will be mapped to +/wildfly-services/ejb/+.

All invocations share some common elements no matter the underlying service that are detailed here.

Note that when using multiple servers/clusters with different deployments behind the same load balancer it will be necessary to map each cluster to a different path. For instance if you have 5 servers serving application A and 7 servers serving application B each group of servers must have a different context path configured so that the load balancer knows where to send the requests.

Some services will use the +JSESSIONID+ cookie to set an affinity with a particular node. If this cookie is sent its path must be equal to the cluster service context path.

=== Versioning

All requests are versioned, with the version specified in the +Content-Type+ header of the request as a parameter named +version+. If the server is not able to process the specified version it will send back a +406+ response with the accept parameter detailing supported versions. All servers and clients that implement a given protocol must support version 1. A client may query the supported versions by sending a +HEAD+ request.

=== Request and Response Type

The request and response type is specified through the content type header. All types should be of the form +application/x-wf-$\{type}; version=$version+. In this version of the specification all message versions are version 1.

=== Compression

Compression is optionally supported by all protocols and message types, and is indicated by the +Content-Encoding+. Gzip and Deflate should be supported by default. A client must send an +Accept-Encoding+ header to the server detailing the acceptable compression types if it supports compression.

Request compression is also supported, however as the client has no way to know if the server will be able to decompress it must be prepared to resend a non compressed response if the server cannot process it. If the server cannot process the compressed request it will respond with a +406+ status code and an +Accept-Encoding+ header that specifies the compression types it supports (this header may be empty). A client may query the supported compression types by sending a +HEAD+ request.

=== Standard HTTP compatibility

Note that for any request the client should also be prepared to accept a HTTP response that is not one of the expected messages. This includes +302+ redirects and HTTP basic auth via a +401+ response, as well as handing +404+ and other errors that may be generated by a load balancer that is not aware of the protocol.

=== Security

All protocols should share the same security and authentication mechanisms. In general this should involve the use of standard HTTP authentication mechanisms (BASIC, CLIENT_CERT etc).
TODO: Fill out this section

=== Clustering, mod_cluster and load balancer support

These protocols must support mod_cluster, and should be designed to work with existing load balancers. The +JSESSIONID+ cookie should be used to convey affinity, as this allows existing load balancers that support sticky sessions to work without any modification.

This protocol does not directly support clustering, clustering is achieved using standard HTTP load balancing based techniques.

== EJB Protocol

The EJB protocol is mapped to the +/ejb+ context inside the service context path. When specifying the URI for a request all fields are required, if they are null or empty they should be replaced with a ‘-’ character.

This protocol has been designed to work with the existing EJB client API, however it should also be usable in a simplified standalone manner. This simplified mode will allow a user to provide a URL and credentials to an InitialContext, lookup an EJB and invoke on it.

=== Standalone HTTP client

In addition to supporting the existing EJB client we will also provide a simplified HTTP only client. This client uses a more traditional approach, in that the server URL is provided to the InitialContext as a provider URL, and the resulting EJB proxies are not stateless, but are tied to the connection/URL of the InitialContext that created them. Connection management is automatic, with client managed connection pools and automatic (configurable) timeouts.

This is not intended to replace the existing EJB client library in any way, but to provide a simpler version that is closer to what other application servers provide.

=== Request Messages

==== EJB Invocation
Message Type:: +application/x-wf-ejb-invocation+
Method::: +POST+
URI:: +/ejb/\{applicationName}/\{moduleName}/\{distinctName}/\{beanName}/\{sfsbSessionId}/\{viewClass}/\{methodName}/\{paramType1}/\{paramType1}/...+
Additional Required Headers::
+Accept: +application/x-wf-ejb-response;version=1,application/x-wf-ejb-exception;version=1, application/x-wf-ejb-invocation-id;version=1++
Additional Optional Headers::
+X-wf-ejb-allow-cancellation: true+
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The method body consists of n parameter values, serialized using JBoss Marshalling, followed by a serialized attachments map of the form +Map<String, Object>+.
Notes::
This message sends a request to the server. If the request completes successfully (or is submitted successfully in the case of a void returning async EJB methods) the server will respond with an +x-wf-ejb-response response+. If an error occurred the server will respond with an +x-wf-ejb-exception+ response.

If the +X-wf-ejb-allow-cancellation+ header is true and the target method is an asynchronous method that returns a Future then a +x-wf-ejb-invocation-id+ message will be returned. This method contains the invocation ID of the async method, and the server may retrieve it or cancel it using this async id. In this case a session ID must be used to ensure cancel and retrieve messages are sent to the correct server.

==== EJB Session Open

Message Type:: +application/x-wf-ejb-session-open+
Method::: +POST+
URI:: +/ejb/\{applicationName}/\{moduleName}/\{distinctName}/\{beanName}+
Additional Required Headers::
+Accept: +application/x-wf-ejb-new-session;version=1,application/x-wf-ejb-exception;version=1++
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

This message sends a request to the server. Full details on how it is handled can be found in the specification for the various returned messages.

==== EJB Cancel

Message Type:: +application/x-wf-ejb-cancel+
Method::: ++DELETE++
URI:: +/ejb/\{applicationName}/\{moduleName}/\{distinctName}/\{invocation-id}+
Additional Required Headers::
+Accept: +application/x-wf-ejb-cancelled;version=1++
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

This message cancels an async request.

==== EJB Invocation Result

Message Type:: +application/x-wf-ejb-invocation-result+
Method::: +POST+
URI:: +/ejb/\{applicationName}/\{moduleName}/\{distinctName}/\{invocation-id}+
Additional Required Headers::
+Accept: +application/x-wf-ejb-response;version=1,application/x-wf-ejb-exception;version=1++
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

This method is used to retrieve the body of an async request. Note that this should be sent immediately after the async method invocation was submitted, as the server will not keep async results around forever (as this would constitute a memory leak). By default a server will keep a result for 60 seconds after the async invocation has completed.

=== Response Messages

==== EJB Response

Message Type:: +application/x-wf-ejb-response+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
For non void methods the response body contains the serialized response object, for void methods the response body is empty.
Response Codes::
 * +200+ Returned for a successful invocation
 * +202+ Returned for a successful invocation of an asynchronous method. This will be returned immediately, the request may not have finished processing yet.

==== EJB Exception

Message Type:: +application/x-wf-ejb-exception+
Response Body::
This response body contains a serialized representation of the exception
Response Codes::
 * +400+ General malformed request (missing headers etc)
 * +403+ Authorization failure
 * +404+ Returned if the deployment, EJB, Session ID or method could not be found
 * +408+ Invocation cancelled
 * +500+ Method processing threw an exception

==== EJB New Session

Message Type:: +application/x-wf-ejb-new-session+
Required Headers::
+X-wf-ejb-session-id: \{newSessionId}+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
None
Response Codes::
 * +202+ Returned for a successful invocation
Notes::
In most cases it is expected that session affinity will be used to make sure that invocations on the EJB target the correct server.

==== EJB Invocation ID

Message Type:: +application/x-wf-ejb-invocation-id+
Required Headers::
+X-wf-ejb-invocation-id: \{invocationId}+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
None
Response Codes::
 * +202+ Returned for a successful invocation
Notes::
Note that session affinity must be used to ensure requests for the invocation end up at the correct server.

==== EJB Cancelled
Message Type:: +application/x-wf-ejb-cancelled+
Response Body:: None
Response Codes:: 
 * +202+ Returned for a successful invocation
 * +404+ Returned if the invocation was not found (i.e. it has already completed)

== JNDI Protocol

The JNDI protocol provides similar functionality to the existing remote JNDI implementation, but over HTTP. All JNDI URL’s are prefixed with +/jndi+.

=== Request Messages

==== JNDI Lookup

Message Type:: +application/x-wf-jndi-lookup+
Method:: +POST+
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-value;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.
Notes::
This message sends a JNDI Lookup request to the server. If the request completes successfully the server will respond with an +x-wf-jndi-value+ response. If an error occurred the server will respond with an +x-wf-jndi-exception+ response.

Note that because JNDI lookups are not idempotent this method is a +POST+, rather than a +GET+ (namely lookups can cause the creation of SFSB’s).

==== JNDI Lookup Link

Message Type:: +application/x-wf-jndi-lookup-link+
Method:: POST
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-value;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers:: Cookie: JSESSIONID=\{sessionAffinityKey}
Request Body:: The request body is empty
Notes:: This message sends a JNDI Lookup Link request to the server. If the request completes successfully the server will respond with an +x-wf-jndi-value response+. If an error occurred the server will respond with an +x-wf-jndi-exception+ response.

Note that because JNDI lookups are not idempotent this method is a post, rather than a +GET+ (namely lookups can cause the creation of SFSB’s).

==== JNDI Bind

Message Type:: +application/x-wf-jndi-bind+
Method:: PUT
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-result;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers:: 
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
Serialized representation of the object to bind

==== JNDI Rebind
Message Type:: +application/x-wf-jndi-rebind+
Method:: +PATCH+
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-result;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers:: 
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
Serialized representation of the object to rebind

==== JNDI Unbind

Message Type:: +application/x-wf-jndi-unbind+
Method:: ++DELETE++
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-result;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None

==== JNDI Destroy Subcontext

Message Type:: +application/x-wf-jndi-destroy+
Method:: +DELETE+
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-result;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None

==== JNDI List

Message Type:: +application/x-wf-jndi-list+
Method:: +GET+
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-value;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None
Notes::
The response messages are the same as for a normal lookup, but contains a serialized +NamingEnumeration+.

==== JNDI List Bindings

Message Type:: +application/x-wf-jndi-list-bindings+
Method:: +POST+
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-value;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None
Notes::
The response messages are the same as for a normal lookup, but contains a serialized NamingEnumeration

==== JNDI Rename
Message Type:: +application/x-wf-jndi-rename+
Method:: +PATCH+
URI:: +/jndi?old=\{jndiName}&new=\{newName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-result;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None

==== JNDI Create Subcontext

Message Type:: +application/x-wf-jndi-create-subcontext+
Method:: +PUT+
URI:: +/jndi?name=\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-result;version=1,application/x-wf-jndi-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None

=== JNDI Response Messages

==== JNDI Value

Message Type:: +application/x-wf-jndi-value+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
The serialized lookup result
Response Codes::
 * +200+ Returned for a successful invocation

==== JNDI Exception

Message Type:: +application/x-wf-jndi-exception+
Response Body::
This response body contains a serialized representation of the exception
Response Codes::
 * +400+ General malformed request (missing headers etc)
 * +403+ Authorization failure
 * +404+ Returned if the object could not be found (i.e. +NameNotFoundException+)
 * +500+ Lookup caused an exception

==== JNDI Result
Message Type:: +application/x-wf-jndi-result+
Response Body::
Empty
Response Codes::
 * +200+ Success
Notes::
This response is only used to indicate success for void returning methods.

== Transaction Support

=== Request Messages

==== Transaction Begin

Message Type:: +application/x-wf-txn-begin+
Method:: +POST+
URI:: +/txn/\{type}+
Additional Required Headers::
+Accept: application/x-wf-txn-new;version=1,application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.
Notes::
Supported types are +ut+ and +xa+ which corresponds to user transactions and distributed transaction respectively.

==== Transaction Commit

Message Type:: +application/x-wf-txn-commit+
Method:: +POST+
URI:: +/txn/\{type}/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-txn-result;version=1,application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Transaction Rollback

Message Type:: +application/x-wf-txn-rollback+
Method:: +DELETE+
URI:: +/txn/\{type}/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-txn-result;version=1,application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Transaction before completion

Message Type:: +application/x-wf-txn-before-completion+
Method:: +POST+
URI:: +/txn/xa/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-txn-result;version=1,application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Distributed Transaction Prepare

Message Type:: +application/x-wf-txn-prepare+
Method:: +POST+
URI:: +/txn/xa/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-txn-result;version=1,application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Distributed Transaction Commit

Message Type:: +application/x-wf-txn-commit+
Method:: +POST+
URI:: +/txn/xa/\{transactionId}(?opc)?+
Additional Required Headers::
+Accept: application/x-wf-txn-result;version=1,application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.
Notes::
If the opc request parameter is present then a one phase commit is done.

==== Distributed Transaction Forget

Message Type:: +application/x-wf-txn-forget+
Method:: +POST+
URI:: +/txn/xa/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-txn-result;version=1,application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Distributed Transaction Recovery

Message Type:: +application/x-wf-txn-recovery+
Method:: +GET+
URI:: +/txn/xa+
Additional Required Headers::
+Accept: text/x-wf-txn-xids;version=1,application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

=== Transaction Responses

==== New Transaction

Message Type:: +application/x-wf-txn-new+
Required Headers::
+X-wf-txn-id: \{transactionId}+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
None
Response Codes::
 * +202+ Returned for a successful invocation

==== Transaction Exception

Message Type:: +application/x-wf-txn-exception+
Response Body::
The response body contains a serialized representation of the exception
Response Codes::
 * +400+ General malformed request (missing headers etc)
 * +403+ Authorization failure
 * +404+ Returned if the transaction could not be found
 * +500+ Transaction processing threw an exception

==== Transaction Result

Message Type:: +application/x-wf-txn-result+
Response Body::
Empty
Response Codes::
 * +200+ Success
Notes::
This response is used to indicate operation success

==== Transaction XIDS

Message Type:: +text/x-wf-txn-xids+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
Newline separated list of prepared but not submitted transactions
Response Codes::
 * +200+ Returned for a successful invocation
