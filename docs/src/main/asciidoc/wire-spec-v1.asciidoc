= Wildfly Service Invocation over HTTP Specification
:Author:    Stuart Douglas
:Email:     <sdouglas@redhat.com>
:Date:      2016
:Revision:  1.0
:toc:   left


== Overview

This document specifies the way in which EJB and other services may be invoked over HTTP. At present this includes:

* EJB
* JNDI
* Transactions

However more may be added in future versions.

=== Design notes

This protocol is intended to conform to HTTP semantics as closely as possible, however it is not intended to be a RESTful protocol. The semantics of EJB invocation to not necessarily map well to REST, and JAX-RS already provides a standard way to map EJB invocation to RESTful web services.

TODO: do we hard code the 'river' marshalling strategy or do we require a header that specifies the strategy?

== Protocol

The protocol is based on HTTP, and is intended to be used over both HTTP/1.1 and HTTP/2. All services are mapped a location in the _Cluster Service Context Path_ which by default is +/wildfly-services+. This context path is configurable per connector, and can be disabled entirely. Each specific protocol will be mapped to a sub location inside the service context path. For example EJB will be mapped to +/wildfly-services/ejb/+.

All invocations share some common elements no matter the underlying service that are detailed here.

Note that when using multiple servers/clusters with different deployments behind the same load balancer it will be necessary to map each cluster to a different path. For instance if you have 5 servers serving application A and 7 servers serving application B each group of servers must have a different context path configured so that the load balancer knows where to send the requests.

Some services will use the +JSESSIONID+ cookie to set an affinity with a particular node. If this cookie is sent its path must be equal to the cluster service context path.

=== Versioning

All requests are versioned, with the version specified in the +Content-Type+ header of the request as a parameter named +version+. If the server is not able to process the specified version it will send back a +406+ response with the accept parameter detailing supported versions. All servers and clients that implement a given protocol must support version 1. A client may query the supported versions by sending a +HEAD+ request.

=== Request and Response Type

The request and response type is specified through the content type header. All types should be of the form +application/x-wf-$\{type}; version=$version+. In this version of the specification all message versions are version 1.

=== Compression

Compression is optionally supported by all protocols and message types, and is indicated by the +Content-Encoding+. Gzip should be supported by default. A client must send an +Accept-Encoding+ header to the server detailing the acceptable compression types if it supports compression.

Request compression is also supported, however as the client has no way to know if the server will be able to decompress it must be prepared to resend a non compressed response if the server cannot process it. If the server cannot process the compressed request it will respond with a +406+ status code and an +Accept-Encoding+ header that specifies the compression types it supports (this header may be empty). A client may query the supported compression types by sending a +HEAD+ request.

=== Standard HTTP compatibility

Note that for any request the client should also be prepared to accept a HTTP response that is not one of the expected messages. This includes +302+ redirects and HTTP basic auth via a +401+ response, as well as handing +404+ and other errors that may be generated by a load balancer that is not aware of the protocol.

=== Security

All protocols should share the same security and authentication mechanisms. In general this should involve the use of standard HTTP authentication mechanisms (BASIC, CLIENT_CERT etc).
TODO: Fill out this section

=== Clustering, mod_cluster and load balancer support

These protocols must support mod_cluster, and should be designed to work with existing load balancers. The +JSESSIONID+ cookie should be used to convey affinity, as this allows existing load balancers that support sticky sessions to work without any modification.

This protocol does not directly support clustering, clustering is achieved using standard HTTP load balancing based techniques.

== Common Messages


==== Session Affinity

Method::: ++GET++
URI:: +/common/v1/affinity+
Additional Required Headers::
Request Body::
The request body is empty.

This message generates a session id, that can be used to make sure requests end up at the same backend node.


==== Session Affinity Result

Required Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body:: None
Response Codes::
 * +202+ Returned for a successful invocation

== EJB Protocol

The EJB protocol is mapped to the +/ejb+ context inside the service context path. When specifying the URI for a request all fields are required, if they are null or empty they should be replaced with a ‘-’ character.

This protocol has been designed to work with the existing EJB client API.

Cancellation support is provided through the use of a client side invocation id and a session cookie. The session cookie makes sure a cancellation goes to the correct server and ensures there are no conflicts, while the invocation id is used to identity the invocation to cancel.

=== Request Messages

==== EJB Invocation
Message Type:: +application/x-wf-jbmar-invocation+
Method::: +POST+
URI:: +/ejb/v1/invoke/\{applicationName}/\{moduleName}/\{distinctName}/\{beanName}/\{sfsbSessionId}/\{viewClass}/\{methodName}/\{paramType1}/\{paramType1}/...+
Additional Required Headers::
+Accept: application/x-wf-ejb-jbmar-response;version=1,application/x-wf-ejb-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
X-wf-invocation-id: {invocationId}
Request Body::
The method body consists of n parameter values, serialized using JBoss Marshalling, followed by a serialized attachments map of the form +Map<String, Object>+.
Notes::
This message sends a request to the server. If the request completes successfully (or is submitted successfully in the case of a void returning async EJB methods) the server will respond with an +x-wf-ejb-jbmar-response response+. If an error occurred the server will respond with an +x-wf-ejb-jbmar-exception+ response.

If the invocation id is specified the session id must also be specified. The client can use an affinity message to get a session id if it does not already have one. The invocation id should only be set for requests that require cancellation support.

The sfsbSessionId parameter is a base64 encoded representation of the SFSB EJB session id, if the invocation is not targeting a stateful bean then it should be a +-+.

==== EJB Session Open

Method::: +POST+
URI:: +/ejb/v1/new/\{applicationName}/\{moduleName}/\{distinctName}/\{beanName}+
Additional Required Headers::
+Accept: application/x-wf-ejb-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

This message sends a request to the server. Full details on how it is handled can be found in the specification for the various returned messages.

==== EJB Cancel

Method::: ++DELETE++
URI:: +/ejb/v1/cancel/\{applicationName}/\{moduleName}/\{distinctName}/\{invocation-id}+
Additional Required Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

This message cancels an async request.

=== Response Messages

==== EJB Response

Message Type:: +application/x-wf-ejb-jbmar-response+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
For non void methods the response body contains the serialized response object, followed by the serialized attachments map. For void methods the serialized object will be the serialized representation of +null+.
Response Codes::
 * +200+ Returned for a successful invocation
 * +202+ Returned for a successful invocation of an asynchronous method. This will be returned immediately, the request may not have finished processing yet.

==== EJB Exception

Message Type:: +application/x-wf-ejb-jbmar-exception+
Response Body::
This response body contains a serialized representation of the exception, followed by a serialized representation of the attachments map
Response Codes::
 * +400+ General malformed request (missing headers etc)
 * +403+ Authorization failure
 * +404+ Returned if the deployment, EJB, Session ID or method could not be found
 * +408+ Invocation cancelled
 * +500+ Method processing threw an exception

==== EJB New Session

Required Headers::
+x-wf-ejb-session-id: \{newSessionId}+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
None
Response Codes::
 * +204+ Returned for a successful invocation
Notes::
In most cases it is expected that session affinity will be used to make sure that invocations on the EJB target the correct server.

==== EJB Cancelled
Response Body:: None
Response Codes:: 
 * +202+ Returned for a successful invocation
 * +404+ Returned if the invocation was not found (i.e. it has already completed)

== JNDI Protocol

The JNDI protocol provides similar functionality to the existing remote JNDI implementation, but over HTTP. All JNDI URL’s are prefixed with +/jndi+.

=== Request Messages

==== JNDI Lookup

Method:: +POST+
URI:: +/jndi/v1/lookup/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.
Notes::
This message sends a JNDI Lookup request to the server. If the request completes successfully the server will respond with an +x-wf-jndi-jbmar-value+ response. If an error occurred the server will respond with an +x-wf-jndi-jbmar-exception+ response.

Note that because JNDI lookups are not idempotent this method is a +POST+, rather than a +GET+ (namely lookups can cause the creation of SFSB’s).

==== JNDI Lookup Link

Method:: POST
URI:: +/jndi/v1/lookuplink/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers:: Cookie: JSESSIONID=\{sessionAffinityKey}
Request Body:: The request body is empty
Notes:: This message sends a JNDI Lookup Link request to the server. If the request completes successfully the server will respond with an +x-wf-jndi-jbmar-value response+. If an error occurred the server will respond with an +x-wf-jndi-jbmar-exception+ response.

Note that because JNDI lookups are not idempotent this method is a post, rather than a +GET+ (namely lookups can cause the creation of SFSB’s).

==== JNDI Bind

Message Type:: +application/x-wf-jndi-jbmar-bind+
Method:: PUT
URI:: +/jndi/v1/bind/\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers:: 
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
Serialized representation of the object to bind

==== JNDI Rebind
Message Type:: +application/x-wf-jndi-jbmar-rebind+
Method:: +PATCH+
URI:: +/jndi/v1/rebind/\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers:: 
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
Serialized representation of the object to rebind

==== JNDI Unbind

Message Type:: +application/x-wf-jndi-jbmar-unbind+
Method:: ++DELETE++
URI:: +/jndi/v1/unbind/\{jndiName}+
Additional Required Headers:: 
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None

==== JNDI Destroy Subcontext

Message Type:: +application/x-wf-jndi-jbmar-destroy+
Method:: +DELETE+
URI:: +/jndi/v1/dest-subctx\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-result;version=1,application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None

==== JNDI List

Message Type:: +application/x-wf-jndi-jbmar-list+
Method:: +GET+
URI:: +/jndi/v1/list/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None
Notes::
The response messages are the same as for a normal lookup, but contains a serialized +NamingEnumeration+.

==== JNDI List Bindings

Message Type:: +application/x-wf-jndi-jbmar-list-bindings+
Method:: +POST+
URI:: +/jndi/v1/list-bindings/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-value;version=1,application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None
Notes::
The response messages are the same as for a normal lookup, but contains a serialized NamingEnumeration

==== JNDI Rename
Message Type:: +application/x-wf-jndi-jbmar-rename+
Method:: +PATCH+
URI:: +/jndi/v1/rename/\{jndiName}&new=\{newName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None

==== JNDI Create Subcontext

Message Type:: +application/x-wf-jndi-jbmar-create-subcontext+
Method:: +PUT+
URI:: +/jndi/v1/create-subcontext/\{jndiName}+
Additional Required Headers::
+Accept: application/x-wf-jndi-jbmar-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
None

=== JNDI Response Messages

==== JNDI Value

Message Type:: +application/x-wf-jndi-jbmar-value+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
The serialized lookup result
Response Codes::
 * +200+ Returned for a successful invocation

==== JNDI Exception

Message Type:: +application/x-wf-jndi-jbmar-exception+
Response Body::
This response body contains a serialized representation of the exception
Response Codes::
 * +400+ General malformed request (missing headers etc)
 * +403+ Authorization failure
 * +404+ Returned if the object could not be found (i.e. +NameNotFoundException+)
 * +500+ Lookup caused an exception

==== JNDI Result
Response Body::
Empty
Response Codes::
 * +200+ Success
Notes::
This response is only used to indicate success for void returning methods.

== Transaction Support

=== Request Messages

==== Transaction Commit

Method:: +POST+
URI:: +/txn/v1/\{type}/commit\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Transaction Rollback

Method:: +DELETE+
URI:: +/txn/v1/\{type}/rollback/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Transaction before completion

Method:: +POST+
URI:: +/txn/v1/xa/bc/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Distributed Transaction Prepare

Method:: +POST+
URI:: +/txn/v1/xa/prep/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Distributed Transaction Commit

Method:: +POST+
URI:: +/txn/v1/xa/commit/\{transactionId}(?opc)?+
Additional Required Headers::
+Accept: application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.
Notes::
If the opc request parameter is present then a one phase commit is done.

==== Distributed Transaction Forget

Method:: +POST+
URI:: +/txn/v1/xa/forget/\{transactionId}+
Additional Required Headers::
+Accept: application/x-wf-tx-exception;version=1+
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

==== Distributed Transaction Recovery

Method:: +GET+
URI:: +/txn/v1/xa/recover+
Additional Required Headers::
+Accept: text/x-wf-txn-jbmar-xids;version=1,application/x-wf-tx-exception;version=1+
x-wf-txn-jbmar-parent-node-name: The parent node name
x-wf-txn-jbmar-recovery-flags: The recovery flags as a base 10 integer
Additional Optional Headers::
+Cookie: JSESSIONID=\{sessionAffinityKey}+
Request Body::
The request body is empty.

=== Transaction Responses

==== New Transaction

Required Headers::
+x-wf-txn-jbmar-id: \{transactionId}+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
None
Response Codes::
 * +202+ Returned for a successful invocation

==== Transaction Exception

Message Type:: +application/x-wf-txn-jbmar-exception+
Response Body::
The response body contains a serialized representation of the exception
Response Codes::
 * +400+ General malformed request (missing headers etc)
 * +403+ Authorization failure
 * +404+ Returned if the transaction could not be found
 * +500+ Transaction processing threw an exception

==== Transaction Result

Response Body::
Empty
Response Codes::
 * +204+ Success
Optional Headers:
x-wf-txn-jbmar-xa-read-only:true :: If this is present then the XA result was read only (only relevant for the prepare operation)
Notes::
This response is used to indicate operation success


==== Transaction XIDS

Message Type:: +text/x-wf-txn-jbmar-xids+
Optional Headers::
+Set-Cookie: JSESSIONID=\{sessionAffinityKey}+
Response Body::
Newline separated list of prepared but not submitted transactions
Response Codes::
 * +200+ Returned for a successful invocation
